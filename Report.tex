\chapter{\Large{Рівні стійкості криптографічних примітивів}}
\label{chap:security-levels}

Сучасна криптографія базується на формальних визначеннях безпеки, які дозволяють математично доводити стійкість 
криптографічних схем~\cite{KatzLindell2020}. Ці визначення формулюються у вигляді \emph{ігор безпеки} (security games) 
між супротивником (adversary) та челенджером (challenger), де супротивник намагається порушити якусь властивість 
криптосистеми~\cite{Goldreich2001}. В першому розділі розглянемо основні рівні стійкості криптографічних примітивів: 
односторонність (one-wayness), нерозрізненість (indistinguishability), семантична стійкість (semantic security) та 
стійкість до перетворень (non-malleability). Ці поняття аналізуються в контексті різних моделей атак, зокрема атак 
на основі обраного відкритого тексту (CPA), неадаптивних атак на основі обраного шифротексту (CCA-1) та адаптивних 
атак на основі обраного шифротексту (CCA-2)~\cite{BellareDesaiPointcheval1998}.

\section{Моделі атак}
\label{sec:1-attack-models}

Перед переходом безпосередньо до рівнів стійкості необхідно визначити моделі атак, які характеризують спектр 
можливостей супротивника. Нехай $\PKE = (\KeyGen, \Enc, \Dec)$ -- асиметрична схема шифрування (Public Key Encryption) 
з простором повідомлень $\mathcal{M}$ та простором шифротекстів $\mathcal{C}$~\cite{KatzLindell2020}.

\subsection{Chosen Plaintext Attack (CPA/CMA)}
\label{subsec:1-1}

В моделі атаки на основі обраного відкритого тексту супротивник має доступ до відкритого ключа $\pk$ і може 
обчислювати шифротексти для довільних повідомлень за власним вибором. Формально, супротивник $\mathcal{A}$ має 
оракульний доступ до функції шифрування $\Enc_{\pk}(\cdot)$ (тобто має можливість надсилати запити до 
функції/алгоритму оракула і отримувати коректні відповіді без знання внутрішнього ключа або його механізму 
роботи)~\cite{Goldwasser1984}.

\begin{definition}[CPA-супротивник~\cite{MenezesOorschotVanstone1996}]
    \label{def:cpa-adversary}
    ~\par CPA-супротивником називається ймовірнісний поліноміальний алгоритм $\mathcal{A}$, який отримує на вхід 
    відкритий ключ $\pk$ та має доступ до оракула шифрування $\Enc_{\pk}(\cdot)$.
\end{definition}

Для детермінованих схем шифрування з відкритим ключем доступ до оракула шифрування не надає додаткової переваги, 
оскільки супротивник може самостійно обчислити $\Enc_{\pk}(m)$ для будь-якого $m$~\cite{KatzLindell2020}.

\subsection{Non-adaptive Chosen Ciphertext attack (CCA-1)}
\label{subsec:1-2}

В моделі CCA-1 (також відомій як "lunchtime attack"{} або Naor-Yung attack), супротивник додатково має доступ до 
оракула дешифрування $\Dec_{\sk}(\cdot)$, але лише \emph{до} отримання challenge-шифротексту~\cite{NaorYung1990}.

\begin{definition}[CCA-1 супротивник~\cite{MenezesOorschotVanstone1996}]
    \label{def:cca1-adversary}
    ~\par CCA-1 супротивником називається ймовірнісний поліноміальний алгоритм 
    $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$, де:
    \begin{itemize}[noitemsep]
        \item $\mathcal{A}_1$ отримує $\pk$ та має доступ до $\Dec_{\sk}(\cdot)$, генерує стан $\mathsf{state}$;
        \item $\mathcal{A}_2$ отримує challenge та $\mathsf{state}$, але \emph{не має} доступу до $\Dec_{\sk}(\cdot)$.
    \end{itemize}
\end{definition}

\subsection{Adaptive Chosen Ciphertext attack (CCA-2)}
\label{subsec:1-3}

Модель CCA-2, запропонована Рекоффом і Саймоном, є "найсильнішою"(найгіршою з точки зору захисту){} стандартною 
моделлю атаки~\cite{RackoffSimon1991}. Супротивник має доступ до оракула дешифрування як до, так і після отримання 
challenge-шифротексту, з єдиним обмеженням -- він не може запитувати дешифрування самого challenge-шифротексту.

\begin{definition}[CCA-2 супротивник~\cite{MenezesOorschotVanstone1996}]
    \label{def:cca2-adversary}
    ~\par CCA-2 супротивником називається ймовірнісний поліноміальний алгоритм 
    $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$, де обидві фази мають доступ до $\Dec_{\sk}(\cdot)$, 
    з обмеженням, що $\mathcal{A}_2$ не може запитувати дешифрування challenge-шифротексту $c^*$.
\end{definition}

Згрупуємо ці атаки у порівняльну таблицю~\ref{tab:attack-models}.

\begin{table}[htbp]
    \centering
    \begin{tblr}{
        colspec = {X[l] X[c] X[c] X[c]},
        row{1} = {font=\bfseries},
        hlines,
        vlines,
        }
        Привілегії                                 & CPA & CCA-1 & CCA-2            \\
        Доступ до $\pk$                            & Так & Так   & Так              \\
        Оракул $\Enc_{\pk}(\cdot)$                 & Так & Так   & Так              \\
        Оракул $\Dec_{\sk}(\cdot)$ до challenge    & Ні  & Так   & Так              \\
        Оракул $\Dec_{\sk}(\cdot)$ після challenge & Ні  & Ні    & Так (крім $c^*$) \\
    \end{tblr}
    \caption{Порівняння моделей атак за можливостями супротивника}
    \label{tab:attack-models}
\end{table}

\section{Односторонність (One-Wayness)}
\label{sec:1-onewayness}

Односторонність є \emph{найслабшим} рівнем стійкості для схем шифрування. Вона вимагає, щоб супротивник не міг 
повністю відновити відкритий текст із шифротексту~\cite{BellareDesaiPointcheval1998}.

\begin{definition}[OW-CPA стійкість]
    \label{def:ow-cpa}
    ~\par Нехай $\PKE = (\KeyGen, \Enc, \Dec)$ -- асиметрична схема шифрування, простір можливих атак: 
    $\mathsf{CPA} \in \{\mathsf{CPA}, \mathsf{CCA1}, \mathsf{CCA2}\}$. Схема $\PKE$ називається OW-CPA стійкою, 
    якщо для будь-якого $\PPT$(Probabilistic Polynomial-Time)-супротивника $\mathcal{A}$ типу CPA:
    \begin{equation*}
        \label{eq:ow-cpa}
        \Adv^{\mathsf{OW-CPA}}_{\PKE, \mathcal{A}}(\lambda) = \Pr\left[\mathcal{A}(\pk, c^*) = m : \substack{(\pk, \sk) \leftarrow \KeyGen(1^\lambda) \\ m \xleftarrow{p} \mathcal{M} \\ c^* \leftarrow \Enc_{\pk}(m)}\right] \leq \negl(\lambda),
    \end{equation*}
    де $\lambda$ -- параметр безпеки.
\end{definition}

\noindent Security game для OW-CPA наведена в алгоритмі~\ref{alg:ow-cpa}.

\begin{algorithm}[htbp]
    \caption{Game OW-CPA для асиметричного шифрування}
    \label{alg:ow-cpa}
    \begin{algorithmic}[1]
        \Require Параметр безпеки $1^\lambda$, супротивник $\mathcal{A}$
        \Ensure Біт $b \in \{0, 1\}$
        \State $(\pk, \sk) \leftarrow \KeyGen(1^\lambda)$
        \State $m \xleftarrow{p} \mathcal{M}$
        \State $c^* \leftarrow \Enc_{\pk}(m)$
        \State $m' \leftarrow \mathcal{A}(\pk, c^*)$
        \If{$m' = m$}
        \State \Return $1$ \Comment{guess successful}
        \Else
        \State \Return $0$ \Comment{guess failed}
        \EndIf
    \end{algorithmic}
\end{algorithm}

Механізм інкапсуляції ключів (Key Encapsulation Mechanism, KEM) є криптографічним примітивом, що складається з 
трьох алгоритмів $\mathsf{KEM} = (\KeyGen, \Encaps, \Decaps)$~\cite{Shoup2001}.

\begin{definition}[OW-CPA стійкість KEM]
    \label{def:ow-cpa-kem}
    ~\par KEM $= (\KeyGen, \Encaps, \Decaps)$ називається OW-CPA стійким, якщо для будь-якого $\PPT$-супротивника 
    $\mathcal{A}$:
    \begin{equation*}
        \label{eq:ow-cpa-kem}
        \Adv^{\mathsf{OW-CPA}}_{\mathsf{KEM}, \mathcal{A}}(\lambda) = \Pr\left[\mathcal{A}(\pk, c^*) = K : \substack{(\pk, \sk) \leftarrow \KeyGen(1^\lambda) \\ (K, c^*) \leftarrow \Encaps(\pk)}\right] \leq \negl(\lambda).
    \end{equation*}
\end{definition}

\section{Нерозрізненість (Indistinguishability)}
\label{sec:1-indistinguishability}

Нерозрізненість є значно сильнішим поняттям безпеки, ніж односторонність. Вона вимагає, щоб супротивник не міг 
отримати \emph{жодної} інформації про відкритий текст із шифротексту~\cite{Goldwasser1984}.

\begin{definition}[IND-CPA стійкість]
    \label{def:ind-cpa}
    ~\par Схема шифрування $\PKE = (\KeyGen, \Enc, \Dec)$ називається IND-CPA стійкою (Indist\-inguishability 
    under Chosen Plaintext Attack), $\mathsf{CPA} \in \{\mathsf{CPA}, \mathsf{CCA1}, \mathsf{CCA2}\}$, якщо для 
    будь-якого $\PPT$-супротивника $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$:
    \begin{equation*}
        \label{eq:ind-cpa}
        \Adv^{\mathsf{IND-CPA}}_{\PKE, \mathcal{A}}(\lambda) = \left|\Pr[b' = b] - \frac{1}{2}\right| \leq \negl(\lambda),
    \end{equation*}
    де "Гра"{} визначена в алгоритмі~\ref{alg:ind-cca2}.
\end{definition}

\begin{algorithm}[htbp]
    \caption{Game IND-CCA2 для асиметричного шифрування}
    \label{alg:ind-cca2}
    \begin{algorithmic}[1]
        \Require Параметр безпеки $1^{\lambda}$, супротивник $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$
        \Ensure Біт $b' \in \{0, 1\}$
        \State $(\pk, \sk) \leftarrow \KeyGen(1^\lambda)$
        \State $(m_0, m_1, \mathsf{state}) \leftarrow \mathcal{A}_1^{\Dec_{\sk}(\cdot)}(\pk)$ \Comment{$|m_0| = |m_1|$}
        \State $b \xleftarrow{p} \{0, 1\}$
        \State $c^* \leftarrow \Enc_{\pk}(m_b)$
        \State $b' \leftarrow \mathcal{A}_2^{\Dec_{\sk}(\cdot)}(c^*, \mathsf{state})$ \Comment{$\mathcal{A}_2$ 
            не може запитувати $\Dec_{\sk}(c^*)$}
        \State \Return $b'$
    \end{algorithmic}
\end{algorithm}

\begin{definition}[IND-CPA стійкість KEM]
    \label{def:ind-cpa-kem}
    ~\par KEM називається IND-CPA стійким, якщо для будь-якого $\PPT$-супротивника $\mathcal{A}$:
    \begin{equation*}
        \label{eq:ind-cpa-kem}
        \Adv^{\mathsf{IND-CPA}}_{\mathsf{KEM}, \mathcal{A}}(\lambda) = \left|\Pr[\mathcal{A}(\pk, c^*, K_b) = b] - \frac{1}{2}\right| \leq \negl(\lambda),
    \end{equation*}
    де $K_0 = K$ -- справжній ключ з $(K, c^*) \leftarrow \Encaps(\pk)$, а $K_1 \xleftarrow{p} \mathcal{K}$ -- 
    випадковий ключ.
\end{definition}

\section{Семантична стійкість (Semantic Security)}
\label{sec:1-semantic-security}

Семантична стійкість, введена Голдвассер та Мікалі~\cite{Goldwasser1984}, є симуляційним означенням безпеки. 
Інтуїтивно: схема є семантично стійкою, якщо будь-яку інформацію про відкритий текст, яку можна ефективно 
обчислити з шифротексту, можна також ефективно обчислити без шифротексту.

\begin{definition}[SS-CPA стійкість]
    \label{def:ss-cpa}
    ~\par Схема шифрування $\PKE$ називається SS-CPA стійкою, якщо для будь-якого $\PPT$-супротивника $\mathcal{A}$ 
    існує $\PPT$-симулятор $\mathcal{S}$ такий, що для будь-якої функції $f: \mathcal{M} \to \{0,1\}^*$ та розподілу 
    $\mathcal{D}$ на $\mathcal{M}$:
    \begin{equation*}
        \label{eq:ss-cpa}
        \left|\Pr[\mathcal{A}(\pk, \Enc_{\pk}(m)) = f(m)] - \Pr[\mathcal{S}(\pk, 1^{|m|}) = f(m)]\right| \leq \negl(\lambda),
    \end{equation*}
    де $m \leftarrow \mathcal{D}$.
\end{definition}

\begin{claim}[Еквівалентність IND та SS~\cite{Goldwasser1984, Micali1984}]
    \label{cl:ind-ss-equivalence}
    ~\par Для моделі Chosen Plaintext Attack (CPA) маємо: $\mathsf{IND\text{-}CPA} \Leftrightarrow \mathsf{SS\text{-}CPA}$.
\end{claim}

\noindent Цей результат був розширений Белларе та ін.~\cite{BellareDesaiPointcheval1998} на моделі CCA-1 та CCA-2:
\begin{equation*}
    \label{eq:ind-ss-equivalence-cca}
    \mathsf{IND\text{-}CCA1} \Leftrightarrow \mathsf{SS\text{-}CCA1}, \quad \mathsf{IND\text{-}CCA2} \Leftrightarrow \mathsf{SS\text{-}CCA2}.
\end{equation*}

\section{Стійкість до перетворень (Non-Malleability)}
\label{sec:1-non-malleability}

Стійкість до перетворень (non-malleability) є напрямком захисту від атак, де супротивник намагається 
створити шифротекст, пов'язаний із challenge-шифротекстом~\cite{DolenvDworkNaor1991}.

\begin{definition}[NM-CPA стійкість]
    \label{def:nm-cpa}
    ~\par Схема $\PKE$ називається NM-CPA стійкою, якщо для будь-якого $\PPT$-супротивника $\mathcal{A}$, для 
    будь-якого відношення $R$ та розподілу $\mathcal{D}$:
    \begin{equation*}
        \label{eq:nm-cpa}
        \Pr\left[\substack{R(m, \mathbf{m}') = 1 \land\, c^* \notin \mathbf{c}'} : 
        \substack{(\pk, \sk) \leftarrow \KeyGen(1^\lambda) \\ m \leftarrow \mathcal{D} \\ c^* \leftarrow \Enc_{\pk}(m) \\ \mathbf{c}' \leftarrow \mathcal{A}(\pk, c^*) \\ \mathbf{m}' \leftarrow \Dec_{\sk}(\mathbf{c}')}\right] 
        \approx \Pr\left[R(m, \mathbf{m}') = 1 : \substack{m \leftarrow \mathcal{D} \\ \mathbf{m}' \leftarrow \mathcal{S}(\pk, 1^{|m|})}\right].
    \end{equation*}
\end{definition}

В моєму розумінні означення~\cite{BellareDesaiPointcheval1998}, схема є NM-стійкою, якщо маючи шифротекст $c^*$, 
супротивник не може створити такий вектор шифротекстів $\mathbf{c}'$, дешифрування яких утворює вектор 
$\mathbf{m}'$, що є лінійною комбінацією оригінального повідомлення $m$.

\section{Порівняльний аналіз означень}
\label{sec:1-compare-properties}

\begin{table}[htbp]
    \centering
    \begin{tblr}{
            colspec = {X[1.5,l] X[2.5,l] X[1.5,l]},
            row{1} = {font=\bfseries},
            hlines,
            vlines,
        }
        Означення                     & На що спрямований захист             & Тип означення    \\
        OW (односторонність)          & Повне відновлення повідомлення       & Обчислювальне    \\
        IND (нерозрізненість)         & Будь-яка інформація про повідомлення & Game-based       \\
        SS (семантична стійкість)     & Будь-яка функція від шифротексту     & Simulation-based \\
        NM (стійкість до перетворень) & Створення пов'язаних шифротекстів    & Simulation-based \\
    \end{tblr}
    \caption{Властивості різних рівнів стійкості}
    \label{tab:security-properties}
\end{table}

\section{Ієрархія та імплікації між рівнями стійкості}
\label{sec:1-hierarchy}

Між різними рівнями стійкості існують певні імплікаційні співвідношення, які формують ієрархію 
стійкості~\cite{BellareDesaiPointcheval1998, BellareSahai1999}.

\subsection{За типом атаки}
\label{subsec:1-4}

Для фіксованого рівня стійкості $X \in \{\mathsf{OW}, \mathsf{IND}, \mathsf{SS}, \mathsf{NM}\}$:
\begin{equation*}
    \label{eq:attack-implications}
    X\text{-}\mathsf{CCA2} \Rightarrow X\text{-}\mathsf{CCA1} \Rightarrow X\text{-}\mathsf{CPA}.
\end{equation*}

Ці імплікації є односторонніми (зворотні імплікації не виконуються в загальному випадку)~\cite{BellareDesaiPointcheval1998}.

\subsection{За рівнем стійкості}
\label{subsec:1-5}

Для фіксованого типу атаки $\mathsf{CPA} \in \{\mathsf{CPA}, \mathsf{CCA1}, \mathsf{CCA2}\}$~\cite{BellareDesaiPointcheval1998, BellareSahai1999}:
\begin{equation*}
    \label{eq:level-implications}
    \mathsf{NM\text{-}CPA} \Rightarrow \mathsf{IND\text{-}CPA} \Leftrightarrow \mathsf{SS\text{-}CPA} \Rightarrow \mathsf{OW\text{-}CPA}.
\end{equation*}

\noindent \textcolor{red}{(!)} Важливим фактом є те, що для CCA-2 атак нерозрізненість та стійкість до перетворень є 
еквівалентними поняттямм~\cite{BellareSahai1999}:
\begin{equation*}
    \label{eq:ind-nm-cca2}
    \mathsf{IND\text{-}CCA2} \Leftrightarrow \mathsf{NM\text{-}CCA2}.
\end{equation*}

\noindent А для CPA ця еквівалентність не виконується:
\begin{equation*}
    \label{eq:nm-cpa-stronger}
    \mathsf{NM\text{-}CPA} \Rightarrow \mathsf{IND\text{-}CPA}, \quad \text{але} \quad \mathsf{IND\text{-}CPA} \not\Rightarrow \mathsf{NM\text{-}CPA}.
\end{equation*}

\subsection{Загальна ієрархія}
\label{subsec:1-6}

Ієрархію рівнів стійкості для асиметричного шифрування можна гарно відобразити рисунком~\ref{fig:hierarchy}.

Стрілками позначимо імплікації. IND-CCA2 $\Leftrightarrow$ NM-CCA2 -- єдина еквівалентність між IND та NM.

Найвищим рівнем стійкості для схем асиметричного шифрування є IND-CCA2 (еквівалентно NM-CCA2). Цей рівень є 
"золотим стандартом"{} для практичних криптосистем~\cite{BellareSahai1999}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm and 2cm,
        box/.style={rectangle, draw, minimum width=2.2cm, minimum height=0.8cm, align=center},
        arrow/.style={-{Stealth[length=2mm]}, thick}
        ]
        % Матриця вузлів для точного вирівнювання
        \matrix[row sep=1.5cm, column sep=1.5cm] {
            \node[box] (owcca2) {OW-CCA2};   &
            \node[box] (indcca2) {IND-CCA2}; &
            \node[box] (nmcca2) {NM-CCA2};     \\

            \node[box] (owcca1) {OW-CCA1};   &
            \node[box] (indcca1) {IND-CCA1}; &
            \node[box] (nmcca1) {NM-CCA1};     \\

            \node[box] (owcpa) {OW-CPA};     &
            \node[box] (indcpa) {IND-CPA};   &
            \node[box] (nmcpa) {NM-CPA};       \\
        };

        % Еквівалентність IND-CCA2 та NM-CCA2
        \draw[arrow, <->, line width = 1.2pt] (indcca2) -- (nmcca2);

        % Вертикальні імплікації для OW
        \draw[arrow] (owcca2) -- (owcca1);
        \draw[arrow] (owcca1) -- (owcpa);

        % Вертикальні імплікації для IND
        \draw[arrow] (indcca2) -- (indcca1);
        \draw[arrow] (indcca1) -- (indcpa);

        % Вертикальні імплікації для NM
        \draw[arrow] (nmcca2) -- (nmcca1);
        \draw[arrow] (nmcca1) -- (nmcpa);

        % Горизонтальні імплікації IND -> OW
        \draw[arrow] (indcca2) -- (owcca2);
        \draw[arrow] (indcca1) -- (owcca1);
        \draw[arrow] (indcpa) -- (owcpa);

        % NM -> IND (для CCA-1 та CPA)
        \draw[arrow] (nmcca1) -- (indcca1);
        \draw[arrow] (nmcpa) -- (indcpa);

    \end{tikzpicture}
    \caption{Ієрархія рівнів стійкості криптопримітивів.}
    \label{fig:hierarchy}
\end{figure}

\section{Приклади криптопримітивів}
\label{sec:1-examples}

\subsection{Криптопримітиви з доведеною стійкістю}
\label{subsec:1-7}

\subsubsection*{RSA-OAEP (IND-CCA2)}

RSA-OAEP (Optimal Asymmetric Encryption Padding) є стандартизованою схемою шифрування з відкритим ключем~\cite{BellareRogaway1994}. 
Схема використовує RSA-функцію з використанням оптимального падінгу, що базується на двох різних геш-функціях. 
Алгоритм шифрування RSA-OAEP є наступним:

\begin{algorithm}[htbp]
    \caption{RSA-OAEP шифрування}
    \label{alg:rsa-oaep}
    \begin{algorithmic}[1]
        \Require Повідомлення $m$, відкритий ключ $(n, e)$, геш-функції $G, H$
        \Ensure Шифротекст $c$
        \State $r \xleftarrow{p} \{0,1\}^{k_0}$ \Comment{Випадкове значення}
        \State $s \leftarrow (m \| 0^{k_1}) \oplus G(r)$
        \State $t \leftarrow r \oplus H(s)$
        \State $w \leftarrow s \| t$
        \State $c \leftarrow w^e \Mod n$
        \State \Return $c$
    \end{algorithmic}
\end{algorithm}

\begin{claim}[Стійкість RSA-OAEP~\cite{FujisakiOkamotoPoincheval2004}]
    ~\par RSA-OAEP є IND-CCA2 стійкою в моделі випадкового оракула за припущення складності RSA-задачі.
\end{claim}

\subsubsection*{Cramer-Shoup (IND-CCA2 без ROM)}

Схема Крамера-Шоупа є першою практичною схемою шифрування з відкритим ключем, для якої доведена IND-CCA2 стійкість 
у стандартній моделі (без випадкового оракула)~\cite{CramerShoup1998}.

\begin{claim}[Стійкість Cramer--Shoup~\cite{CramerShoup2003}]
    ~\par Схема Cramer--Shoup є IND-CCA2 стійкою за припущення DDH (Decisional Diffie--Hellman assumption).
\end{claim}

\subsubsection*{ML-KEM (a.k.a Kyber)}

ML-KEM (Module-Lattice-based Key Encapsulation Mechanism), раніше відомий як CRYSTALS-Kyber, є стандартизованим 
постквантовим KEM~\cite{NIST-FIPS-203}. Він був обраний NIST (National Institute of Standards and Technology) як 
стандарт для постквантової криптографії.

\begin{claim}[Стійкість ML-KEM~\cite{Kyber2021}]
    ~\par ML-KEM є IND-CCA2 стійким за припущення складності задачі MLWE (Module Learning with Errors).
\end{claim}

\subsection{Криптопримітиви, що не задовольняють певним рівням стійкості}
\label{subsec:1-8}

\subsubsection*{Textbook RSA}

"Підручникова"{} схема RSA (Rivest-Shamir-Adleman without padding) не задовольняє навіть найслабшому рівню 
нерозрізненості IND-CPA~\cite{KatzLindell2020}.

\begin{proof}
    ~\par Нехай $(\pk, \sk) = ((n, e), d)$ -- ключова пара RSA. Розглянемо супротивника $\mathcal{A}$, який:
    \begin{enumerate}[noitemsep]
        \item Вибирає повідомлення $m_0$, $m_1$;
        \item Отримує challenge-шифротекст $c^* = m_b^e \Mod n$;
        \item Обчислює $c_0 = m_0^e \Mod n$;
        \item Якщо $c^* = c_0$, виводить $b' = 0$, інакше $b' = 1$.
    \end{enumerate}
    Оскільки RSA є детермінованим алгоритмом, то зловмисник $\mathcal{A}$ вгадує правильно з ймовірністю 
    $\Adv^{\mathsf{IND-CPA}}_{\mathsf{RSA}, \mathcal{A}} = 1/2$.
    Окрім цього, Textbook RSA має властивість \emph{мультиплікативності}, що робить її вразливою до атак на 
    перетворення (NM-CPA)~\cite{Boneh1999, Bleichenbacher1998}.
    \begin{equation*}
        \label{eq:rsa-multiplicative}
        \Enc(m_1) \cdot \Enc(m_2) = m_1^e \cdot m_2^e = (m_1 \cdot m_2)^e = \Enc(m_1 \cdot m_2) \Mod{n},
    \end{equation*}
\end{proof}

\subsubsection*{ElGamal}

Схема ElGamal є прикладом криптосистеми, яка задовольняє IND-CPA, але не задовольняє IND-CCA1~\cite{ElGamal1985}.

\begin{claim}[Стійкість ElGamal~\cite{TsiounisYung1998}]
    ~\par Схема ElGamal є IND-CPA стійкою за припущення DDH, але не є IND-CCA2 стійкою (і, як наслідок, не є 
    IND-CCA1 стійкою).
\end{claim}

\begin{proof}
    Нехай $\pk = (G, g, h = g^x)$. Супротивник $\mathcal{A}$ діє наступним чином:
    \begin{enumerate}[noitemsep]
        \item Вибирає два повідомлення $m_0, m_1 \in G$;
        \item Отримує challenge-шифротекст $c^* = (c_1, c_2) = (g^r, m_b \cdot h^r)$;
        \item Формує модифікований шифротекст $c' = (c_1, c_2 \cdot g) = (g^r, m_b \cdot h^r \cdot g)$;
        \item Запитує $\Dec(c')$ у фазі після отримання $c^*$ (це дозволено в CCA-2, оскільки $c' \neq c^*$);
        \item Отримує $m' = m_b \cdot g$ та обчислює $m_b = m' \cdot g^{-1}$;
        \item Виводить $b' = 0$, якщо $m_b = m_0$, інакше $b' = 1$.
    \end{enumerate}
    Супротивник вгадує правильно з ймовірністю $\Adv^{\mathsf{IND-CCA2}} = 1/2$.
\end{proof}

Ця вразливість пов'язана з malleability. Якщо $(c_1, c_2) = (g^r, m \cdot h^r)$ є шифротекстом для $m$, то для
будь-якого відомого $\delta \in G$:
\begin{equation*}
    \label{eq:elgamal-malleability}
    (c_1, c_2 \cdot \delta) = (g^r, m \cdot \delta \cdot h^r) = \Enc(m \cdot \delta),
\end{equation*}
тобто можна отримати валідний шифротекст для $m \cdot \delta$ без знання $m$. Ця властивість є наслідком 
мультиплікативності алгоритму ElGamal:
\begin{equation*}
    \label{eq:elgamal-homomorphic}
    \Enc(m_1) \cdot \Enc(m_2) = (g^{r_1+r_2}, m_1 \cdot m_2 \cdot h^{r_1+r_2}) = \Enc(m_1 \cdot m_2).
\end{equation*}

\subsection{Порівняльна таблиця перелічених алгоритмів}
\label{subsec:1-9}

\begin{table}[htbp]
    \centering
    \begin{tblr}{
            colspec = {X[1.7,l] X[c] X[c] X[c] X[c] X[c] X[c]},
            row{1} = {font=\bfseries},
            hlines,
            vlines,
        }
        Крипто\-примітив & OW-CPA & IND-CPA & IND-CCA1     & IND-CCA2     & NM-CPA & NM-CCA2     \\
        RSA-OAEP       & Так    & Так     & Так          & Так***       & Так    & Так***      \\
        Cramer--Shoup  & Так    & Так     & Так          & Так**        & Так    & Так**       \\
        ML-KEM (Kyber) & Так    & Так     & Так          & Так$^\star$  & Так    & Так$^\star$ \\
        Textbook RSA   & Так*   & Ні      & Ні           & Ні           & Ні     & Ні          \\
        ElGamal        & Так    & Так**   & Ні$^\dagger$ & Ні           & Ні     & Ні          \\
    \end{tblr}
    \begin{flushleft}
        \small
        * --- за припущення складності RSA-задачі; ** --- за припущення DDH; *** --- у моделі випадкового оракула; $\star$ -- за припущення MLWE.\\
        $^\dagger$ --- для ElGamal доведено нестійкість до CCA-2; нестійкість до CCA-1 не має явної простої атаки, але й доказу стійкості немає.
    \end{flushleft}
    \caption{Порівняння рівнів стійкості криптопримітивів}
    \label{tab:primitives-comparison}
\end{table}

\noindent Можна підбити коротенький підсумок:
\begin{enumerate}[noitemsep]
    \item Ієрархія рівнів стійкості: IND-CCA2 (еквівалентно NM-CCA2) є найвищим рівнем стійкості для 
        схем асиметричного шифрування та механізмів інкапсуляції ключів.
    \item Нерозрізненість та семантична стійкість еквівалентні для всіх розглянутих моделей атак (CPA, CCA-1, CCA-2).
    \item Для CCA-2 атак IND та NM еквівалентні, але для CPA атак NM є строго сильнішою вимогою.
    \item Сучасні криптосистеми (RSA-OAEP, Cramer--Shoup, ML-KEM) розробляються з метою досягнення IND-CCA2 
        стійкості так званого "золотого стандарту"{} безпеки.
    \item Приклад Textbook RSA демонструє критичну важливість використання падінгу як такового для досягнення 
        навіть найбазовіших рівнів стійкості.
\end{enumerate}

\chapter{\Large{Рівні стійкості схем цифрового підпису}}
\label{chap:signature-security}

Схеми цифрового підпису(ЦП) є фундаментальним криптографічним примітивом, що забезпечує автентичність та цілісність 
повідомлень~\cite{Goldreich2001, Goldreich2004}. На відміну від схем шифрування, де основною метою є конфіденційність, 
для схем підпису ключовою властивістю є захист від підробок (unforgeability) -- неможливість створення валідного 
підпису без знання секретного ключа~\cite{GoldwasserMicaliRivest1988}.

Формально, схема цифрового підпису складається з трьох алгоритмів~\cite{KatzLindell2020}:
\begin{itemize}[noitemsep]
    \item[] $\Sigma = (\KeyGen, \Sign, \Verify)$:
    \item $\KeyGen(1^\lambda) \to (\pk, \sk)$ --- генерація ключової пари;
    \item $\Sign_{\sk}(m) \to \sigma$ --- створення підпису для повідомлення $m$;
    \item $\Verify_{\pk}(m, \sigma) \to \{0, 1\}$ --- перевірка підпису.
\end{itemize}

\section{Моделі атак на схеми цифрового підпису}
\label{sec:2-attack-models}

Існують багато рівнів стійкості, розглянемо два основних -- універсальна непідробність (universal unforgeability, UU) 
та екзистенційна непідробність (existential unforgeability, EU). Їх доцільно розглядати в контексті різних моделей 
атак, наприклад: KOA (key-only attack), RMA (random message attack) та CPA (chosen message attack). Моделі атак 
на схеми ЦП класифікуються за обсягом інформації, яка доступна супротивнику~\cite{KatzLindell2020, GoldwasserMicaliRivest1988}.

\subsection{Атака лише з відкритим ключем (KOA)}
\label{subsec:2-1}

В моделі KOA (Key-Only Attack) супротивник має доступ лише до відкритого ключа $\pk$. Це найслабша модель атаки, 
оскільки супротивник не має жодних прикладів валідних підписів~\cite{GoldwasserMicaliRivest1988}.

\begin{definition}[KOA-супротивник]
    \label{def:koa-adversary}
    ~\par KOA це $\PPT$(Probabilistic Polynomial-Time)-алгоритм $\mathcal{A}$, який отримує на вхід лише відкритий 
    ключ користувача $\pk$ та намагається створити валідний підпис.
\end{definition}

\subsection{Атака з випадково обраними повідомленнями (RMA)}
\label{subsec:2-2}

В моделі RMA (Random Message(Plaintext) Attack), також відомій як KPA (Known Plaintext Attack), супротивник перехоплює набір 
пар $(m_i, \sigma_i)$, де повідомлення $m_{i}$ обрані випадковим чином~\cite{GoldwasserMicaliRivest1988}.

\begin{definition}[RMA-супротивник]
    \label{def:rma-adversary}
    ~\par RMA-супротивником називається $\PPT$-алгоритм $\mathcal{A}$, який отримує:
    \begin{itemize}[noitemsep]
        \item відкритий ключ $\pk$;
        \item набір пар $\{(m_1, \sigma_1), \ldots, (m_q, \sigma_q)\}$, де $m_i \xleftarrow{p} \mathcal{M}$ та 
            $\sigma_i = \Sign_{\sk}(m_i)$.
    \end{itemize}
\end{definition}

\subsection{Атака на основі вибраного plaintext (CPA)}
\label{subsec:2-3}

Модель CPA (Chosen Plaintext Attack) є найсильнішою стандартною моделлю атаки. Супротивник має адаптивний (ґрунтуючись 
на попередньо отриманих результатах) оракульний доступ до функції підпису $\Sign_{\sk}(\cdot)$ і може запитувати 
підписи для довільних повідомлень за власним вибором~\cite{GoldwasserMicaliRivest1988}.

\begin{definition}[CPA-супротивник]
    \label{def:cma-adversary}
    ~\par CPA-супротивником називається такий поліноміальний алгоритм $\mathcal{A}^{\Sign_{\sk}(\cdot)}$, який:
    \begin{itemize}[noitemsep]
        \item отримуючи відкритий ключ $\pk$;
        \item і маючи адаптивний оракульний доступ до $\Sign_{\sk}(\cdot)$;
        \item може робити поліноміальну кількість запитів до оракула для витягання деталей про $\sk$.
    \end{itemize}
\end{definition}

Всі перелічені атаки можна ґарненько звести до таблиці~\ref{tab:signature-attack-models}.

\begin{table}[htbp]
    \centering
    \begin{tblr}{
            colspec = {X[1.2,l] X[c] X[1.1, c] X[c]},
            row{1} = {font=\bfseries},
            hlines,
            vlines,
        }
        Преференція          & KOA       & RMA                   & CPA                \\
        Sign examples        & Ні        & Так (випадкові $m_i$) & Так (обрані $m_i$) \\
        Адаптивність запитів & Ні        & Ні                    & Так                \\
        Загроза              & Найслабша & Середня               & Найсильніша        \\
    \end{tblr}
    \caption{Порівняння моделей атак на схему цифрового підпису}
    \label{tab:signature-attack-models}
\end{table}

\subsection*{Ієрархія моделей атак}
\label{subsec:2-4}

Між моделями атак існує певна ієрархія залежно від їх сили~\cite{GoldwasserMicaliRivest1988}:
\begin{equation*}
    \label{eq:attack-hierarchy}
    \mathsf{CPA} \succ \mathsf{RMA} \succ \mathsf{KOA},
\end{equation*}
де під позначенням $A \succ B$ розуміємо, що модель $A$ надає супротивнику більше можливостей, ніж модель $B$. 
І відповідно стійкість до більш сильної атаки (позначимо її $X$) включає в себе і стійкість до слабшої:

\begin{equation*}
    \label{eq:attack-implications-sig}
    X\text{-}\mathsf{CPA} \Rightarrow X\text{-}\mathsf{RMA} \Rightarrow X\text{-}\mathsf{KOA}
\end{equation*}

\section{Рівні непідробності}
\label{sec:2-unforgeability}

Рівні непідробності розрізняють залежно від того, що саме вважається успішною підробкою. Розглянемо три основні 
види.

\subsection{Універсальна непідробність (Universal Unforgeability)}
\label{subsec:2-5}

Універсальна непідробність (UU) вимагає, щоб супротивник не міг підробити підпис для \emph{заданого} повідомлення 
$m^{*}$, яке обирається челенджером~\cite{GoldwasserMicaliRivest1988}.

\begin{definition}[UU-ATK стійкість]
    \label{def:uu-atk}
    ~\par Схема підпису $\Sigma = (\KeyGen, \Sign, \Verify)$ називається UU-ATK стійкою, де \\ 
    $\mathsf{ATK} \in \{\mathsf{KOA}, \mathsf{RMA}, \mathsf{CPA}\}$, якщо для будь-якого $\PPT$-супротивника $\mathcal{A}$:
    \begin{equation*}
        \label{eq:uu-atk}
        \Adv^{\mathsf{UU-ATK}}_{\Sigma, \mathcal{A}}(\lambda) = \Pr\left[\Verify_{\pk}(m^*, \sigma^*) = 1 : \substack{(\pk, \sk) \leftarrow \KeyGen(1^\lambda) \\ m^* \xleftarrow{p} \mathcal{M} \\ \sigma^* \leftarrow \mathcal{A}^{\mathcal{O}}(\pk, m^*)}\right] \leq \negl(\lambda),
    \end{equation*}
    де $\mathcal{O}$ -- оракул, визначений моделлю ATK.

    P.S. В моделі CPA супротивник не може запитувати $\Sign_{\sk}(m^*)$.
\end{definition}

Алгоритм "гри"{} UU-CPA наведемо в алгоритмі~\ref{alg:uu-cma}.

\begin{algorithm}[htbp]
    \caption{Game UU-CPA для схеми цифрового підпису}
    \label{alg:uu-cma}
    \begin{algorithmic}[1]
        \Require Параметр безпеки $1^\lambda$
        \Ensure Біт $b \in \{0, 1\}$
        \State $(\pk, \sk) \leftarrow \KeyGen(1^\lambda)$
        \State $m^* \xleftarrow{p} \mathcal{M}$ \Comment{Челенджер обирає цільове повідомлення}
        \State $Q \leftarrow \varnothing$ \Comment{Множина запитаних повідомлень}
        \State $\sigma^* \leftarrow \mathcal{A}^{\Sign_{\sk}(\cdot)}(\pk, m^*)$
        \Comment{$\mathcal{A}$ не може запитувати $\Sign_{\sk}(m^*)$}
        \If{$\Verify_{\pk}(m^*, \sigma^*) = 1$ \textbf{and} $m^* \notin Q$}
        \State \Return $1$ \Comment{Успішна підробка підпису}
        \Else
        \State \Return $0$
        \EndIf
    \end{algorithmic}
\end{algorithm}

\subsection{Екзистенційна непідробність (Existential Unforgeability)}
\label{subsec:2-6}

Екзистенційна несфальсифікованість (EU) є більш сильним поняттям. Вона вимагає, щоб супротивник не міг підробити 
підпис для \emph{будь-якого} повідомлення, яке підписант раніше не підписував~\cite{Chia2021}. Це є "золотим 
стандартом"{} безпеки для цифрових підписів.
\begin{definition}[EU-ATK стійкість]
    \label{def:eu-atk}
    ~\par Схема підпису $\Sigma$ є EU-ATK стійкою, якщо для будь-якого $\PPT$-algorithm $\mathcal{A}$:
    \begin{equation*}
        \label{eq:eu-atk}
        \Adv^{\mathsf{EU-ATK}}_{\Sigma, \mathcal{A}}(\lambda) = \Pr\left[\substack{\Verify_{\pk}(m^*, \sigma^*) = 1 \\ \land\, m^* \notin Q} : \substack{(\pk, \sk) \leftarrow \KeyGen(1^\lambda) \\ (m^*, \sigma^*) \leftarrow \mathcal{A}^{\mathcal{O}}(\pk)}\right] \leq \negl(\lambda),
    \end{equation*}
    де $Q$ -- множина повідомлень, для яких атакуючий $\mathcal{A}$ отримав підписи.
\end{definition}

EU-CPA також доволі часто позначають в літературі як EUF-CMA (Existential Unforgeability under Chosen Message 
Attack)~\cite{KatzLindell2020}.

\newpage %FORCED...
\begin{algorithm}[htbp]
    \caption{Game EU-CPA (EUF-CPA) для схеми цифрового підпису}
    \label{alg:eu-cma}
    \begin{algorithmic}[1]
        \Require Параметр безпеки $1^\lambda$, супротивник $\mathcal{A}$
        \Ensure Біт $b \in \{0, 1\}$
        \State $(\pk, \sk) \leftarrow \KeyGen(1^\lambda)$
        \State $Q \leftarrow \varnothing$
        \State $(m^*, \sigma^*) \leftarrow \mathcal{A}^{\Sign_{\sk}(\cdot)}(\pk)$
        \Comment{$\mathcal{A}$ сам обирає $m^*$}
        \If{$\Verify_{\pk}(m^*, \sigma^*) = 1$ \textbf{and} $m^* \notin Q$}
        \State \Return $1$ \Comment{Успішна підробка}
        \Else
        \State \Return $0$
        \EndIf
    \end{algorithmic}
\end{algorithm}

\subsection{Сильна екзистенційна непідробність (sEU)}
\label{subsec:2-7}

Виділяють також ще одне поняття -- \emph{сильна екзистенційна непідробність} (Strong Unforgeability under Chosen 
Message Attack, sEU a.k.a. SUF), яке додатково запобігає фальсифікації зловмисником дійсного підпису для будь-якого 
нового повідомлення, включаючи те, яке вже було підписано законним підписувачем~\cite{AbdallaAnBellareNamprempre2002}.

\begin{definition}[sEU-CPA стійкість]
    \label{def:seu-cma}
    ~\par Схема $\Sigma$ є sEU-CPA стійкою, якщо супротивник не може створити таку пару $(m^*, \sigma^*)$, що 
    $\Verify_{\pk}(m^*, \sigma^*) = 1 \land (m^*, \sigma^*) \notin Q$, де $Q$ -- множина всіх пар (повідомлення, 
    підпис), отриманих від оракула.
\end{definition}

\subsection*{Зв'язок між рівнями непідробності}
\label{subsec:2-8}

Для фіксованого типу атаки ATK~\cite{KatzLindell2020, GoldwasserMicaliRivest1988}:
\begin{equation*}
    \label{eq:unforgeability-implications}
    \mathsf{sEU\text{-}ATK} \Rightarrow \mathsf{EU\text{-}ATK} \Rightarrow \mathsf{UU\text{-}ATK}.
\end{equation*}
\noindent Ці імплікації є строгими -- зворотні імплікації не виконуються в загальному випадку.

\section{Важливість sEU-CPA (на практиці)}
\label{sec:2-seu-importance}

На перший погляд, різниця між EU-CMA та sEU-CMA може здаватися суто теоретичною: навіщо забороняти створення іншого 
підпису для вже підписаного повідомлення? У рандомізованих схемах підпису, де для одного повідомлення $m$ може 
існувати багато валідних підписів ця відмінність є критичною~\cite{AbdallaAnBellareNamprempre2002}.

Розглянемо до прикладу схему Шнора (більш детально про неї в~\ref{cl:schnorr}). Там підпис має вигляд 
$\sigma = (e, s)$, де $e = H(g^k \| m)$ залежить від випадкового $k$. Для одного повідомлення $m$ з різними 
значеннями $k$ отримаємо різні валідні підписи $\sigma_1, \sigma_2, \ldots$.

\noindent Нехай $\mathcal{A}$ запитав $\Sign(m)$ і отримав $\sigma_1 = (e_1, s_1)$:
\begin{itemize}[noitemsep]
    \item \textbf{EU-CMA}: супротивник повинен підробити підпис для \emph{нового} довільно обраного повідомлення 
        $m^* \neq m$. Оскльки створення іншого валідного підпису $\sigma_2$ для того ж $m$ не є порушенням.
    \item \textbf{sEU-CMA}: супротивник не може створити \emph{жодну} нову пару $(m^*, \sigma^*)$, таку 
        яку не було раніше видано оракулом як відповідь на якийсь запит, навіть $(m, \sigma_2)$, де 
        $\sigma_2 \neq \sigma_1$.
\end{itemize}

Дана sEU-CPA стійкість важлива в тих протоколах, де підпис використовується як унікальний ідентифікатор 
певної транзакції або де дублювання підпису може призвести до replay-атак~\cite{AbdallaAnBellareNamprempre2002}.

\section{Ієрархія рівнів стійкості}
\label{sec:2-hierarchy}

Найвищим стандартним рівнем стійкості для схем цифрового підпису вважають sEU-CPA (SUF-CPA), а практичним "золотим 
стандартом"{} є EU-CPA (EUF-CPA)~\cite{KatzLindell2020}.

Повна ієрархія рівнів стійкості для схем цифрового підпису зображена на рисунку~\ref{fig:signature-hierarchy}. 
Стрілками позначимо імплікації (від сильнішого до слабшого).

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
        box/.style={rectangle, draw, minimum width=2cm, minimum height=0.7cm, align=center, font=\small},
        arrow/.style={-{Stealth[length=2mm]}, thick}
        ]
        % Матриця вузлів для точного вирівнювання
        \matrix[row sep=1.2cm, column sep=1.8cm] {
            \node[box] (seucma) {sEU-CMA}; &
            \node[box] (seurma) {sEU-RMA}; &
            \node[box] (seukoa) {sEU-KOA};   \\

            \node[box] (eucma) {EU-CMA};   &
            \node[box] (eurma) {EU-RMA};   &
            \node[box] (eukoa) {EU-KOA};     \\

            \node[box] (uucma) {UU-CMA};   &
            \node[box] (uurma) {UU-RMA};   &
            \node[box] (uukoa) {UU-KOA};     \\
        };

        % Вертикальні стрілки (sEU -> EU -> UU)
        \draw[arrow] (seucma) -- (eucma);
        \draw[arrow] (seurma) -- (eurma);
        \draw[arrow] (seukoa) -- (eukoa);
        \draw[arrow] (eucma) -- (uucma);
        \draw[arrow] (eurma) -- (uurma);
        \draw[arrow] (eukoa) -- (uukoa);

        % Горизонтальні стрілки (CMA -> RMA -> KOA)
        \draw[arrow] (seucma) -- (seurma);
        \draw[arrow] (seurma) -- (seukoa);
        \draw[arrow] (eucma) -- (eurma);
        \draw[arrow] (eurma) -- (eukoa);
        \draw[arrow] (uucma) -- (uurma);
        \draw[arrow] (uurma) -- (uukoa);

    \end{tikzpicture}
    \caption{Ієрархія рівнів стійкості схем цифрового підпису.}
    \label{fig:signature-hierarchy}
\end{figure}

\section{Приклади криптопримітивів}
\label{sec:2-examples}

\subsection{Схеми з доведеною EU-CPA стійкістю}
\label{subsec:2-11}

\subsubsection*{RSA-PSS (EU-CPA)}

RSA-PSS (Probabilistic Signature Scheme) є стандартизованою схемою підпису, розробленою Белларе та Рогавеєм~\cite{BellareRogaway1996}. 
На відміну від детермінованого RSA-підпису, PSS використовує рандомізацію. Алгоритм підпису RSA-PSS є наступним:

\begin{algorithm}[htbp]
    \caption{RSA-PSS підпис}
    \label{alg:rsa-pss}
    \begin{algorithmic}[1]
        \Require Повідомлення $m$, секретний ключ $d$, модуль $n$, геш-функції $H, G$
        \Ensure Підпис $\sigma$
        \State $r \xleftarrow{p} \{0,1\}^{k_0}$ \Comment{Випадкове значення рандомізації}
        \State $w \leftarrow H(m \| r)$
        \State $r^* \leftarrow G(w) \oplus r$
        \State $y \leftarrow 0 \| w \| r^*$
        \State $\sigma \leftarrow y^d \Mod n$
        \State \Return $\sigma$
    \end{algorithmic}
\end{algorithm}

\begin{claim}[Стійкість RSA-PSS~\cite{BellareRogaway1996}]
    \label{cl:rsa-pss}
    ~\par RSA-PSS є EU-CPA стійкою в моделі випадкового оракула (Random Oracle Model (ROM)) за припущення складності 
    RSA-задачі.
\end{claim}

\subsubsection*{Schnorr (EU-CPA)}

Схема Шнорра є схемою підпису на основі розв'язанні задачі дискретного логарифма~\cite{Schnorr1991}. Вона є основою 
для багатьох сучасних схем підпису, наприклад, EdDSA.

\begin{claim}[Стійкість Schnorr~\cite{PointchevalStern1996}]
    \label{cl:schnorr}
    ~\par Схема Schnorr є EU-CPA стійкою в моделі випадкового оракула за припущення складності задачі 
    дискретного логарифма (DL).
\end{claim}

\noindent Схема виглядає наступним чином:
\begin{algorithm}[htbp]
    \caption{Схема підпису Schnorr}
    \label{alg:schnorr}
    \begin{algorithmic}[1]
        \Statex \textbf{Генерація ключів} $\KeyGen(1^\lambda)$:
        \State $x \xleftarrow{p} \mathbb{Z}_q$
        \State \Return $(\pk = g^x,\; \sk = x)$
        \Statex
        \Statex \textbf{Підпис} $\Sign_{\sk}(m)$:
        \State $k \xleftarrow{p} \mathbb{Z}_q$
        \State $r \leftarrow g^k$
        \State $e \leftarrow H(r \| m)$
        \State $s \leftarrow k + x \cdot e \Mod q$
        \State \Return $\sigma = (e, s)$
        \Statex
        \Statex \textbf{Верифікація} $\Verify_{\pk}(m, \sigma = (e, s))$:
        \State $r' \leftarrow g^s \cdot \pk^{-e}$
        \State \Return $\bigl(H(r' \| m) \overset{?}{=} e\bigr)$
    \end{algorithmic}
\end{algorithm}

\subsubsection*{ECDSA (EU-CPA)}

Згадана мною раніше ECDSA (Elliptic Curve Digital Signature Algorithm) є широко використовуваною схемою підпису, 
стандартизованою у вже застарілому FIPS 186-4~\cite{FIPS186-4}. (Буквально на початку 2024 року вийшло оновлення)

\begin{claim}[Стійкість ECDSA~\cite{BrownECDSA2005}]
    \label{cl:ecdsa}
    ~\par ECDSA є EU-CPA стійкою в моделі generic group за припущення складності ECDLP (Elliptic Curve Discrete 
    Logarithm Problem).
\end{claim}

\subsubsection*{ML-DSA (Dilithium) -- постквантовий підпис}

ML-DSA (Module-Lattice-based Digital Signature Algorithm), раніше відомий як \\
CRYSTALS-Dilithium, є стандартизованим NIST постквантовим підписом (той самий новий, 24 року стандарт)~\cite{NIST-FIPS-204}.

Він є EU-CPA стійким у припущені складності задач MLWE (learning with errors) та MSIS (short integer solution).

\subsection{Схеми без певних рівнів стійкості}
\label{subsec:2-12}

\subsubsection*{Textbook RSA signature}

"Підручникова"{} схема RSA-підпису, де $\sigma = m^d \Mod n$, є вразливою навіть до найслабшої атаки~\cite{KatzLindell2020}. 
Тобто textbook RSA підпис не є EU-KOA стійким, оскільки супротивник, маючи лише $\pk = (n, e)$, може здійснити 
екзистенційну підробку:

\begin{enumerate}[noitemsep]
    \item Вибрає довільне $\sigma^* \in \mathbb{Z}_n^*$;
    \item Обчислює $m^* = (\sigma^*)^e \Mod n$;
    \item Пара $(m^*, \sigma^*)$ є валідним підписом, оскільки за побудовою $(\sigma^*)^e \equiv m^* \Mod{n}$, 
        тому $\Verify_{\pk}(m^*, \sigma^*) = 1$ -- підпис дійсний.
\end{enumerate}

Ця атака демонструє проблему з інверсією: супротивник \emph{спочатку} обирає підпис, а потім обчислює відповідне 
повідомлення. Оскільки значення $m^*$ повністю визначається вибором $\sigma^*$, то $m^*$ як читабельний людиною 
текст не матиме практичного сенсу, але це все одно є порушенням екзистенційної непідробності, бо вимагається 
захист від підробки \emph{будь-якого нового} повідомлення.

Textbook RSA також має властивість \emph{мультиплікативності}, тому крім інверсійної атаки, можлива підробка за 
наявності підписів інших повідомлень -- в моделях RMA (Random Message Attack) та CMA (Chosen Message Attack)~\cite{KatzLindell2020}:

\begin{claim}[Мультиплікативна атака на RSA підпис]
    \label{cl:rsa-multiplicative-attack}
    ~\par Якщо супротивник має підписи $\sigma_1 = m_1^d$ та $\sigma_2 = m_2^d$ для повідомлень $m_1, m_2$, він 
    може обчислити валідний підпис для $m^* = m_1 \cdot m_2 \Mod n$:
    \begin{equation*}
        \sigma^* = \sigma_1 \cdot \sigma_2 = m_1^d \cdot m_2^d = (m_1 \cdot m_2)^d \Mod n = (m^*)^d.
    \end{equation*}
    Це показує, що Textbook RSA не є EU-R/CMA стійкою.
\end{claim}

\subsubsection*{ElGamal signature}

Оригінальна схема підпису ElGamal~\cite{ElGamal1985} має кілька відомих вразливостей. Наприклад, вона є вразливою 
до екзистенційної підробки в моделі KOA (див.~\ref{subsec:2-1}), якщо не використовувати геш-функцію.

\begin{proof}
    ~\par Нехай $p$ -- велике просте число, $g$ -- генератор мультиплікативної групи $\mathbb{Z}_p^{*}$, обрано 
    секретний ключ $\sk = x \xleftarrow{p} \mathbb{Z}_{p-1}$ та обраховано відкритий ключ $\pk = (p, g, y = g^x \Mod{p})$. 
    Підпис для повідомлення $m$ має вигляд $(r, s)$, де $r = g^k \Mod{p}$, $k$ -- випадкове значення, та виконується 
    рівняння верифікації: $g^m = y^r \cdot r^s \Mod{p}$.

    Фальсифікація може відбутися наступним чином:
    \begin{enumerate}[noitemsep]
        \item Обирається $a, b \in \mathbb{Z}_{p-1}^*$, $\gcd(b, p-1) = 1$;
        \item Обчислюється $r = g^a \cdot y^b \Mod{p}$;
        \item Обчислюється $s = -r \cdot b^{-1} \Mod{p-1}$;
        \item Обчислюється $m^{*} = a \cdot s \Mod{p-1}$, $m^{*} = m$.
    \end{enumerate}
    Пара $(r, s)$ буде валідним підписом для $m$.
\end{proof}

\noindent Використання криптографічної геш-функції $H$ (тобто підписуємо $H(m)$ замість вихідного повідомлення 
$m$) запобігає цій атаці.

\newpage % FORCED
\subsection{Порівняльна таблиця розглянутих алгоритмів підпису}
\label{subsec:2-13}

\begin{table}[htbp]
\centering
\begin{tblr}{
        colspec = {Q[2.3,l] X[c] X[c] X[c] X[c] X[c] X[1.1, c]},
        row{1} = {font=\bfseries},
        hlines,
        vlines,
    }
    Схема підпису                          & UU-KOA & UU-CPA & EU-KOA & EU-RMA & EU-CPA        & sEU-CPA       \\
    RSA-PSS                                & Так    & Так    & Так    & Так    & Так*          & Так*          \\
    Schnorr                                & Так    & Так    & Так    & Так    & Так*          & Ні**          \\
    ECDSA                                  & Так    & Так    & Так    & Так    & Так***        & Ні**          \\
    ML-DSA                                 & Так    & Так    & Так    & Так    & Так$^{\star}$ & Так$^{\star}$ \\
    {Textbook RSA \\ ElGamal (без $H$)}    & Ні     & Ні     & Ні     & Ні     & Ні            & Ні            \\
\end{tblr}
\begin{flushleft}
    \small
    * --- в моделі випадкового оракула (ROM); ** --- детерміновані (не ймовірнісні) версії;
    *** --- за припущення складності ECDLP; $^{\star}$ --- за припущення Module-LWE/SIS.
\end{flushleft}
\caption{Порівняння рівнів стійкості схем цифрового підпису}
\label{tab:signature-primitives}
\end{table}

\noindent Проміжний підсумок розділу:

\begin{enumerate}[noitemsep]
    \item Моделі атак характеризуються залежно від рівня загрози (KOA $\prec$ RMA $\prec$ CPA) і стійкість до 
        сильнішої включає в себе стійкість до слабшої;
    \item Рівні непідробності залежать від обмежень (UU $\prec$ EU $\prec$ sEU);
    \item Практичним стандартом безпеки для схем підпису є EU-CPA (EUF-CPA). Сучасні схеми, такі як RSA-PSS, Schnorr, 
        ECDSA, ML-DSA, відповідають йому;
    \item Геш-функції є важливими, оскільки їх використання є критичним для досягнення EU-CPA стійкості (в тому ж ElGamal).
\end{enumerate}

\chapter{\Large{Аналіз стійкості криптографічного примітиву на прикладі TiGER}}
\label{chap:tiger-security}

TiGER (Tiny-polynomial based Ring-LWE/LWR scheme) є постквантовим механізмом інкапсуляції ключів (KEM), розробленим 
у рамках конкурсу KpqC (Korean Post-Quantum Cryptography Competition)~\cite{tiger2023spec}. Алгоритм базується на 
математичних задачах RLWE (Ring Learning With Errors) та RLWR (Ring Learning With Rounding), які вважаються стійкими 
до атак як на класичних, так і на квантових комп'ютерах~\cite{lyubashevsky2010ideal, banerjee2012pseudorandom}.

\section{Основні характеристики TiGER. Його "родзинки"{}}
\label{sec:3-1}
TiGER пропонує три рівні безпеки, що відповідають категоріям NIST~\cite{nist2016submission}:

\begin{itemize}
    \item \textbf{TiGER128:} Рівень безпеки NIST-1 (еквівалент AES-128);
    \item \textbf{TiGER192:} Рівень безпеки NIST-3 (еквівалент AES-192);
    \item \textbf{TiGER256:} Рівень безпеки NIST-5 (еквівалент AES-256).
\end{itemize}

\noindent Ключовими інноваціями TiGER є~\cite{tiger2023spec}:
\begin{enumerate}[noitemsep]
    \item Гібридний підхід RLWE/RLWR для балансу безпеки та ефективності;
    \item Використання подвійної системи корекції помилок (XEf + D2);
    \item Використання розріджених тернарних секретів з ваговою нормою $h_s = 274$;
    \item Застосування перетворення Fujisaki-Okamoto з неявним відхиленням (implicit rejection).
\end{enumerate}

\section{Теоретичні основи безпеки}
\label{sec:3-2}

\subsection{Математична база: RLWE та RLWR}
\label{subsec:3-2-1}

\begin{definition}[RLWE задача]
    \label{def:RLWE}
    ~\par Задача RLWE (Ring Learning With Errors), вперше формалізована Lyubashevsky, Peikert та Regev~\cite{lyubashevsky2010ideal}. \\
    Нехай $R = \mathbb{Z}[x]/(x^n + 1)$, $R_q = \mathbb{Z}_q[x]/(x^n + 1)$ -- кільце многочленів за модулем 
    циклотомічного многочлена, та $\chi$ -- дискретний гаусівський розподіл ймовірностей на $R_q$. Розпізнавальна 
    задача $\text{Decision-RLWE}_{n,q,\chi}$ полягає у розрізненні наступних розподілів:
    \begin{itemize}
        \item $(a, a \cdot s + e)$, де обрано $a \in R_q$ (рівномірний розподіл), $s \in R_q$ фіксоване, 
            $e \xleftarrow{p} \chi$;
        \item $(a, u)$, де $a, u$ обрані рівномірно з $R_q$.
    \end{itemize}
\end{definition}

\begin{definition}[RLWR задача]
    \label{def:RLWR}
    ~\par Задача RLWR (Ring Learning With Rounding). \\
    Нехай $R_q = \mathbb{Z}_q[x]/(x^n + 1)$, $R_p = \mathbb{Z}_p[x]/(x^n + 1)$, де $p < q$. Для кожного коефіцієнта 
    многочлена окремо застосовуються детерміністична функція округлення до найближчого цілого~\cite{banerjee2012pseudorandom}:
    \begin{equation*}
        \lfloor f \rceil_p = \sum\limits_{i=0}^{n-1} \left\lfloor \frac{p}{q} \cdot f_i \right\rceil x^i \bmod p.
    \end{equation*}
    Розпізнавальна задача $\text{Decision-RLWR}_{n,q,p}$ полягає у розрізненні:
    \begin{itemize}
        \item $(a, \lfloor a \cdot s \rceil_p)$, де $a \in R_q$ обрано рівномірно, $s \in R_q$ фіксоване;
        \item $(a, u)$, де $a \in R_q$, $u \in R_p$ обрані рівномірно.
    \end{itemize}
\end{definition}

Варто завважити, що при певних параметрах $n,q,p$, задача RLWR$_{n,q,p}$ є не легшою за задачу RLWE$_{n,q,\chi}$ 
з розподілом помилок $\chi$, що відповідає помилці округлення.

\subsection{Архітектура TiGER KEM}
\label{subsec:3-2-2}

TiGER.KEM будується з застосуванням перетворення Fujisaki-Okamoto~\cite{fujisaki2011secure} для базової PKE схеми:

\begin{algorithm}[H]
    \caption{TiGER.KEM.Encaps}
    \label{alg:kem-encaps}
    \begin{algorithmic}[1]
        \Require Відкритий ключ $pk$
        \Ensure Спільний ключ $K$, шифротекст $ct$
        \State $m \xleftarrow{p} \{0,1\}^{256}$
        \State $r \leftarrow G(m, H(pk))$
        \State $ct \leftarrow \text{TiGER.PKE.Enc}(pk, m; r)$
        \State $K \leftarrow H(m, ct)$
        \State \Return  $(K, ct)$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{TiGER.KEM.Decaps}
    \label{alg:kem-decaps}
    \begin{algorithmic}[1]
        \Require Секретний ключ $sk$, шифротекст $ct$
        \Ensure Спільний ключ $K$ або $\bar{K}$
        \State $m' \leftarrow \text{TiGER.PKE.Dec}(sk, ct)$
        \State $r' \leftarrow G(m', H(pk))$
        \State $ct' \leftarrow \text{TiGER.PKE.Enc}(pk, m'; r')$
        \If{$ct' = ct$}
        \State $K \leftarrow H(m', ct)$
        \Else
        \State $K \leftarrow \bar{K} = H(z, ct)$ \Comment{Implicit rejection (неявне відхилення)}
        \EndIf
        \State \Return $K$
    \end{algorithmic}
\end{algorithm}

\noindent \textcolor{red}{(!)} Використання перетворення FO забезпечує IND-CCA безпеку в моделі квантового 
випадкового оракула (QROM)~\cite{hofheinz2017modular}.

\section{Аналіз атак на TiGER}
\label{sec:3-3}

\subsection{Решіткові атаки}
\label{subsec:3-3-1}

Решіткові атаки (a.k.a. Lattice reduction attack) є основним класом атак на RLWE та RLWR, які спрямовані на розв'язання 
задач SVP (Shortest Vector Problem) або CVP (Closest Vector Problem)~\cite{micciancio2009lattice}. Найбільш відомим 
є алгоритм BKZ (Block Korkine-Zolotarev) редукції~\cite{chen2011bkz} у поєднанні з sieving методами~\cite{becker2016new}.

Для оцінки безпеки TiGER проти квантових атак використовується модель Core-SVP (Short Vector Problem)~\cite{alkim2016newhope},
що вимірює складність вирішення SVP на решітці розмірності $\beta$ (block dimension) і порогове значення для здійснення 
успішної атаки складає $\beta = 483$.

\noindent В класичній моделі обчислень найкращими класичними алгоритми (BKZ + sieving) досягається:
\begin{equation*}
    T_{\text{classical}} \approx 2^{0.292\beta + o(\beta)} = 2^{0.292 \cdot 483 + 16.4} \approx 2^{157} \text{ операцій} 
\end{equation*}

\noindent В квантовому всесвіті, при застосуванні квантових версії sieving алгоритмів (див.~\cite{laarhoven2015sieving}) 
складність досягає:
\begin{equation*}
    T_{\text{quantum}} \approx 2^{0.265\beta + o(\beta)} = 2^{0.265 \cdot 483 + 16.4} \approx 2^{144} \text{ операцій}
\end{equation*}

Решіткові атаки є \textit{універсальними} для всіх RLWE/RLWR схем, включно з TiGER. Проте, параметри TiGER обрані 
доволі консервативно для забезпечення достатньої безпеки:

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Параметр}         & \textbf{Значення}          \\
        \hline
        Розмірність решітки $d$   & 1024                       \\
        Core-SVP $\beta$          & 483                        \\
        Класична складність       & $\approx 2^{157}$ операцій \\
        Квантова складність       & $\approx 2^{144}$ операцій \\
        Класична безпека          & $\approx 143$ біт          \\
        Квантова безпека (NIST 1) & $128$ біт                  \\
        \hline
    \end{tabular}
    \caption{Складність решіткової атаки на TiGER128}
    \label{tab:lattice-attacks-TiGER128}
\end{table}

Навіть з урахуванням можливих майбутніх покращень квантових алгоритмів можна бачити, що злам TiGER128 вимагає 
$2^{128}$ операцій, що є практично нереалістичним.

\noindent \textbf{Статус:} \textcolor{orange}{Атака застосовна, але неефективна}

Отже як висновок: решіткові атаки не становлять практичної загрози для TiGER при заданих параметрах.

\subsection{Meet-in-the-Middle атака на RLWE}
\label{subsec:3-3-2}

Meet-LWE атака, розроблена німецьким криптографом Александром Mеем (Alexander May)~\cite{may2021much}, експлуатує 
розрідженість секретних ключів. Ідея полягає у розбитті секрету на дві частини та пошуку кожної частини окремо з 
подальшим їх поєднанням (meet-in-the-middle стратегія). Для секрету $\mathbf{s}$ з ваговою нормою $h_s$, 
складність становить:
\begin{equation*}
    T_{\text{MitM}} \approx 2^{c \cdot h_s \log_2(3)},
\end{equation*}
де $c < 1$ -- деяка константа, що залежить від параметрів атаки~\cite{may2021much}.

\noindent Для TiGER $h_s = 274$, і Meet-LWE атака досягає квантової складності:

\begin{equation*}
    T_{\text{quantum}} \approx 2^{0.25 \cdot 274 \cdot \log_2(3)} \approx 2^{109.5}.
\end{equation*}

\noindent Це нижче цільового рівня 128 біт, але:
\begin{itemize}
    \item Атака вимагає експоненційної пам'яті: $2^{109.5}$ квантових кубітів для збереження проміжних станів;
    \item Практична реалізація такої атаки на квантовому комп'ютері є нереалістичною навіть у віддаленому майбутньому;
    \item Для TiGER192 і TiGER256 складність зростає до $2^{164}$ та $2^{219}$ відповідно, що значно перевищує 
        можливості для атаки.
\end{itemize}
\textbf{Статус:} \textcolor{orange}{Частково застосовна}

При порівнянні з решітковими атаками, BKZ залишається більш ефективною проти TiGER128 ($2^{128}$ vs $2^{109.5}$), 
але Meet-LWE є теоретично швидша, але практично нереалізованою через величезні вимоги до об'ємів квантової пам'яті.

\subsection{Атаки на ймовірність помилок декапсуляції}
\label{subsec:3-3-3}

Атаки типу failure boosting~\cite{damico2020attack, duman2021estimation} експлуатують ненульову ймовірність 
помилок декапсуляції (Decapsulation/Decryption Failure Probability/Rate, DFP/DFR). Їх ідея полягає у:

\begin{enumerate}[noitemsep]
    \item Генерації спеціальних шифротекстів, які максимізують DFP;
    \item Подача цих шифротекстів до оракула декапсуляції;
    \item Спостереження успіху/невдачі декапсуляції;
    \item Поступове вивідування інформації про секретний ключ.
\end{enumerate}

DFP -- це ймовірність того, що правильно сформований шифротекст декапсулюється некоректно, тобто:
\begin{equation*}
    \text{DFP} = \Pr[\text{Decaps}(sk, \text{Encaps}(pk)) \neq K] = \delta
\end{equation*}
А кількість необхідних запитів для витягування секрету становить $O(1/\delta)$~\cite{damico2020attack}.

\noindent TiGER має два рівні захисту від цієї атаки:

\begin{itemize}
    \item Перше -- це дуже низький DFP (досягається завдяки подвійній корекції помилок (XEf + D2)). З специфікації TiGER~\cite{tiger2023spec} 
        (заявлена DFP) складає: $\text{DFP}_{\text{TiGER128}} = 2^{-120}$. Це означає, що атакуючому потрібно 
        $2^{120}$ запитів для спостереження хоча б однієї помилки.
    \item Друге -- це Implicit Rejection (IR). Перетворення FO$^{\not\bot}_m$ з неявним відхиленням~\cite{hofheinz2017modular} 
        гарантує нам, що при невдалій перевірці $ct' \neq ct$ алгоритм не повертає помилку $\bot$, а замість цього 
        повертається псевдовипадковий ключ $\bar{K} = H(z, ct)$, і атакуючий не може відрізнити успішну декапсуляцію 
        від невдалої. Схематично це зображено на малюнку~\ref{fig:implicit-rejection}.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2cm, auto, thick]
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1cm] (ct) {Шифротекст $ct$};
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1cm, below of=ct] (dec) {Дешифрування};
        \node[draw, diamond, aspect=2, minimum width=3cm, below of=dec] (check) {$ct' = ct$?};
        \node[draw, rectangle, minimum width=2cm, minimum height=0.8cm, below left=1.5cm and 2cm of check] (k) {$K = H(m', ct)$};
        \node[draw, rectangle, minimum width=2cm, minimum height=0.8cm, below right=1.5cm and 2cm of check] (kbar) {$\bar{K} = H(z, ct)$};

        \draw[->] (ct) -- (dec);
        \draw[->] (dec) -- node[right] {$m', r'$} (check);
        \draw[->] (check) -- node[above=0.1cm] {Так} (k);
        \draw[->] (check) -- node[above=0.1cm] {Ні} (kbar);

        \node[below=0.3cm of k, text width=2.5cm, align=center, font=\small] {Детермінований};
        \node[below=0.3cm of kbar, text width=2.5cm, align=center, font=\small] {Псевдовипадковий};
    \end{tikzpicture}
    \caption{Схема implicit rejection у TiGER}
    \label{fig:implicit-rejection}
\end{figure}

\noindent \textbf{Статус:} \textcolor{Green4}{Не застосовна}

Атаки на DFP повністю мітиговані в TiGER завдяки вдалій комбінації низької ймовірності помилок DFP та використанні 
implicit rejection.

\subsection{Атаки з вибором шифротексту (CCA)}
\label{subsec:3-3-4}

Атаки з вибраним шифротекстом a.k.a. CCA (Chosen Ciphertext Attack)~\cite{Bleichenbacher1998} є одними з 
найнебезпечніших атак на криптосистеми. В 2024 році von Berg з колегами опублікував роботу~\cite{vonberg2024}, 
що аналізує CCA атаку на PKE схеми на основі решіток, включаючи варіанти наближені до TiGER. Ці атаки дозволяють 
атакуючому:
\begin{itemize}
    \item Подавати довільні (в т.ч. модифіковані) шифротексти на оракул декапсуляції;
    \item Отримувати результати декапсуляції або спостерігати побічні ефекти (помилки);
    \item Витягати інформацію про секретний ключ або повідомлення.
\end{itemize}
CCA атаки особливо ефективні проти базових PKE схем без додаткових перетворень~\cite{Bleichenbacher1998}.

TiGER використовує \textit{не базову PKE}, а KEM з перетворенням Fujisaki-Okamoto (FO), яке перетворює IND-CPA 
безпечну PKE в IND-CCA2 безпечний KEM. Це перетворення захищає від CCA атак, бо:
\begin{enumerate}
    \item \textbf{Re-encryption check:} Дешифроване $\mu'$ використовується для повторного шифрування. Якщо 
        результат не збігається з $ct$, значить $ct$ був модифікований атакуючим;
    \item \textbf{Детермінованість:} Шифрування використовує $H'(\mu)$ як seed для помилок, тому одне $\mu$ 
        завжди видає той самий $ct$ (для даного $pk$). Ключ $K = H(\mu)$ повністю визначається повідомленням, 
        тому модифікація $ct$ дає інший $\mu'$ та, відповідно, інший $K'$, що виглядає як випадкове значення 
        для атакуючого.
    \item \textbf{Implicit rejection:} Навіть якщо перевірка провалилася, атакуючий не дізнається про це, оскільки 
        отримує псевдовипадковий $\bar{K}$;
\end{enumerate}

\noindent Формальне доведення IND-CCA безпеки в моделі QROM наведено у~\cite{hofheinz2017modular}, яке демонструє 
що FO$^{\not\bot}_m$ перетворення забезпечує IND-CCA2 безпеку за умов:
\begin{itemize}
    \item Базова PKE є IND-CPA безпечною;
    \item Геш-функції $H, H'$ моделюються як випадкові оракули (ROM);
    \item DFP/R схеми є достатньо малим значенням.
\end{itemize}

\noindent \textbf{Статус:} \textcolor{Green4}{Не застосовна}

Висновок -- TiGER є стійким до CCA атак завдяки FO перетворенню з implicit rejection (IR).

\subsection{Атаки на коди корекції помилок}
\label{subsec:3-3-5}

Атака з урахуванням(спрямована на) XEf коду~\cite{guo2021key} намагається експлуатувати алгебраїчну структуру 
кодів корекції помилок. Ідея полягає в маніпуляції шифротекстами для створення специфічних синдромів і 
спостереженні поведінки декодера (успіх/невдача корекції).

Синдром це лінійна операція XOR над $\mathbb{F}_2$, а це означає, що:
\begin{equation*}
    s(\mathbf{m}_1 \oplus \mathbf{m}_2) = s(\mathbf{m}_1) \oplus s(\mathbf{m}_2)
\end{equation*}

\noindent Припустимо, що зловмисник знає частину бітів повідомлення $\mu$ та хоче знайти решту, використовуючи 
лінійність синдромів. Він зіштовхнеться з наступними проблемами:

\begin{enumerate}
    \item Синдроми є внутрішньою частиною коду корекції та не передаються разом з шифротекстом;
    \item Навіть якщо атакуючому вдасться відтворити процес кодування, йому потрібно знати 
        \textit{точні помилки} від RLWE/компресії (а вони випадкові);
    \item Оскльки без знання помилок, система лінійних рівнянь на синдроми має занадто багато невідомих:
        \begin{itemize}
            \item 32 синдроми (по одному на блок) $\to$ 32 рівняння;
            \item Невідомі: 256 біт $\mu$ + помилки від RLWE (кожна має ентропію 
                $\approx n \cdot h_e = 512 \cdot 274 \approx 140,000$ біт) $\to$ система сильно недовизначена.
        \end{itemize}
\end{enumerate}

\noindent Атаки, що спрямовані на XEf код корекції помилок є небезпечними, але TiGER має кілька рівнів захисту, 
що робить ці атаки практично нездійсненними:
\begin{enumerate}
    \item \textbf{Високий рівень шуму} -- RLWE помилки та компресія маскують структуру коду;
    \item \textbf{Подвійна корекція (XEf + D2)} --- навіть якщо XEf зламано, D2 надає додатковий захист;
    \item \textbf{Implicit rejection} -- унеможливлює спостереження success/failure декапсуляції;
    \item \textbf{FO перетворення} --- re-encryption check виявляє модифіковані шифротексти.
\end{enumerate}
\textbf{Статус:} \textcolor{Green4}{Теоретично застосовна, практично неефективна}

Висновок: структура XEf не створює додаткових вразливостей у TiGER завдяки багаторівневому захисту.

\subsection{Side-channel attacks}
\label{subsec:3-3-6}

Side-channel атаки експлуатують фізичні характеристики при реалізації алгоритму: такі як час виконання, споживання 
енергії, електромагнітне випромінювання, індукування помилок задля обходу перевірок, аналіз паттернів доступу до кешу, 
замість безпосередньої атаки на математичну структуру. Для TiGER, як і для всіх постквантових алгоритмів, side-channel 
атаки становлять серйозну практичну загрозу~\cite{kocher1996timing, kocher1999differential}.

Side-channel атаки є \textit{найсерйознішою практичною загрозою} для TiGER, оскільки майже ідеальна математична 
конструкція не захищає від витоку інформації через фізичні канали.

\begin{table}[htbp]
    \centering
    \begin{tblr}{
            colspec = {|Q[l, 3.0cm]| Q[l, 5.0cm] | Q[l, 5.0cm] |},
            vlines,
            hlines,
            row{1} = {c},
        }
        \textbf{Тип атаки}       & \textbf{Що відстежується}            & \textbf{Цільова інформація}                          \\
        \hline
        Timing attack            & Час виконання операцій               & Секретний ключ $\mathbf{s}$, проміжні значення $\mu$ \\
        \hline
        Power analysis (SPA/DPA) & Споживання енергії                   & Біти секретного ключа $\mathbf{s}$ при множенні      \\
        \hline
        EM analysis              & Електромагнітне випромінювання       & Аналогічно до power analysis                         \\
        \hline
        Cache timing             & Паттерни доступу до кешу             & Індекси ненульових коефіцієнтів $\mathbf{s}$         \\
        \hline
        Fault injection          & Індукування помилок                  & Обхід перевірок Decaps                               \\
    \end{tblr}
    \caption{Типи side-channel атак}
    \label{table:side-channel}
\end{table}

Контрзаходи, які можливо запровадити для зменшення ризиків side-channel атак:

\begin{enumerate}[noitemsep]
    \item \textbf{Constant-time реалізація:} Всі операції виконуються за фіксований час незалежно від розміру 
        вхідних даних~\cite{bernstein2005cache};
    \item \textbf{Masking:} Розділення секрету $\mathbf{s}$ на $d$ випадкових часток~\cite{coron2014higher}:
        \begin{equation*}
            \mathbf{s} = \mathbf{s}_0 \oplus \mathbf{s}_1 \oplus \ldots \oplus \mathbf{s}_d,
        \end{equation*}
        де $d$ --- порядок masking (рекомендується хоча б першого порядку);
    \item \textbf{Shuffling:} Випадковізація порядку операцій~\cite{rivain2010provably};
    \item \textbf{Подвійна перевірка:} Для захисту від fault injection виконувати re-encryption check двічі (!) 
        незалежними одне від одного способами.
    \item \textbf{Апаратні контрзаходи:} Використання HSM, secure enclaves.
\end{enumerate}
\textbf{Статус:} \textcolor{red}{Застосовна, вимагає ретельного захисту}

Підсумовуючи вищезазначене, можна сказати що: side-channel атаки є найсерйознішою практичною загрозою для TiGER. 
Математична конструкція алгоритму стійка, але паршива реалізація може призводити до витоків секретів через фізичні 
канали і скомпрометувати загальну безпеку. Це вимагає впровадженню обов'язкових контрзаходів на рівні реалізації. 

\section{Порівняльні таблиці для TiGER}
\label{sec:3-4}

\subsection{Порівняння атак на TiGER}
\label{subsec:3-4-1}

Тут наведу підсумкові таблиці, думаю з них все і так зрозуміло :)
\begin{table}[H]
    \label{table:7-1-2}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Тип атаки} & \textbf{Складність} & \textbf{Рівень загрози}      & \textbf{Захист}           \\
        \hline
        \hline
        BKZ                & $2^{144}$ (квант.)  & \textcolor{Green4}{Безпечно}  & Достатнє значення $\beta$ \\
        \hline
        Brutforce          & $2^{393}$ (Grover)  & \textcolor{Green4}{Безпечно}  & Large key space           \\
        \hline
        RLWR specific      & ?                   & \textcolor{Green4}{Безпечно}  & Редукція до RLWE          \\
        \hline
        Timing             & Варіюється          & \textcolor{orange}{Помірний} & Const-time implementation \\
        \hline
        Power analysis     & Варіюється          & \textcolor{orange}{Помірний} & Mask using                \\
        \hline
        Fault injection    & Варіюється          & \textcolor{Green4}{Безпечно}  & Implicit rejection        \\
        \hline
    \end{tabular}
    \centering
    \caption{Слабкі місця TiGER}
\end{table}

\begin{table}[H]
    \centering
    \begin{tblr}{
            colspec = {X[l,m] Q[c,m] X[l,m]},
            hlines, vlines,
            row{1} = {font=\bfseries, c},
        }
        Тип атаки        & Застосовність                  & Захист                                                  \\
        Решіткові (BKZ)  & \textcolor{orange}{Частково}   & Консервативні параметри забезпечують складність         \\
        Meet-LWE         & \textcolor{orange}{Частково}   & Нереалістичний об'єм квантової пам'яті                  \\
        Failure boosting & \textcolor{Green4}{Ні}         & DFP $< 2^{-120}$ і implicit rejection                   \\
        CCA              & \textcolor{Green4}{Ні}         & FO перетворення з re-encryption check                   \\
        Side-channel     & \textcolor{red}{Так}           & Сonstant-time реалізація, masking, апаратні контрзаходи \\
        Атаки на XEf     & \textcolor{Green4}{Теоретично} & Подвійна корекція + implicit rejection + FO             \\
    \end{tblr}
    \caption{Застосовність відомих атак до TiGER}
    \label{tab:attacks-summary}
\end{table}

\textbf{Загальний висновок:} Як бачимо, TiGER не має критичних математичних вразливостей. Основні його ризики пов'язані 
з side-channel атаками, які потребують обережної реалізації. Його "Cryptographic Core Architecture"{} є стійкою до всіх 
відомих теоретичних атак при заданих оптимальних параметрах.

\subsection{Порівняння з іншими PQC алгоритмами}
\label{subsec:3-4-2}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Алгоритм} & \textbf{Решіткові} & \textbf{Meet-LWE} & \textbf{DFP захист} & \textbf{Side-channel$^*$} \\
        \hline
        Kyber             & Стійкий            & Частково          & Низька DFP          & Вразливий                 \\
        \hline
        Saber             & Стійкий            & Частково          & Низька DFP          & Вразливий                 \\
        \hline
        TiGER             & Стійкий            & Частково          & IR + низька DFP     & Вразливий                 \\
        \hline
        SMAUG-T$^{\star}$ & Стійкий            & Частково          & IR + низька DFP     & Вразливий                 \\
        \hline
    \end{tabular}
    \caption{Порівняння стійкості TiGER з іншими постквантовими KEM}
    \label{tab:pqc-comparison}
    \vspace{2mm}
    \begin{flushleft}
        {\small $\star$ -- криптопримітив, що оснований на TiGER; \\ $^*$ -- Усі алгоритми вимагають constant-time реалізації, masking та апаратних контрзаходів}
    \end{flushleft}
\end{table}

\subsubsection*{Підсумочок:}

TiGER є \textbf{криптографічно стійким} постквантовим KEM алгоритмом, який ефективно протидіє відомим 
математичним атакам. Його математична конструкція базується на перевірених припущеннях складності (RLWE/RLWR) і дотримується 
балансу компактності та безпеки, а додаткові механізми (FO перетворення, implicit rejection, подвійна корекція помилок) 
забезпечують багаторівневий захист.

Основні ризики зосереджені більше у площині реалізації -- side-channel атаки потребують обов'язкових контрзаходів. 
За умови дотримання рекомендацій щодо безпечної реалізації, TiGER може забезпечити надійний захист від квантових 
загроз для широкого спектру загроз на довгі роки. Злиття TiGER з SMAUG у алгоритм SMAUG-T та його визнання фіналістом 
KpqC підтверджує перспективність підходу та високу оцінку експертним криптографічним співтовариством.

P.S. Більш детально я розглядав цей алгоритм в своїй іншій~\href{https://github.com/Dyggas/TiGER-implementation-MAC-lab/tree/dev/LaTeX}{лабораторній роботі}.
